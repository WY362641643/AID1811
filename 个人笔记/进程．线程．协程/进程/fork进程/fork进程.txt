
多进程编程

import  os

pid = os.fork()
功能： 创建新的进程
返回值：失败   返回一个负数
       成功   在原进程中返回新进程的PID号
	          在新进程中返回0


*****使用fork创建新的进程*******     

一. fork()创建子进程特点
    1. 子进程会复制父进程全部的内存空间和代码段
    2. 子进程会从fork的下一句开始执行
    3. if...elif...else结构正是根据父子进程fork的返回
        值不同让父子进程执行不同的内容，几乎是fork的固
        定搭配
    4. 父子进程运行互不影响，使用同一个终端，运行顺序
        不定
    5. 子进程有自己特有的PID，PCB，命令集等
    6. 进入阻塞状态的进程一定会让出cpu时间片
    7. 子进程连同fork之前开辟的空间也会复制。但是父子
        进程各自空间独立，操作各自空间内容，互不影响


二、进程相关函数使用
    
    os.getpid()
    功能：   获取当前进程的PID号
    返回值：  返回PID号

    os.getppid()
    功能:   获取父进程的PID号
    返回值： 返回 父进程PID号

    os._exit(status)
    功能：  退出一个进程
    参数：  表示进程退出状态 

    sys.exit([status])
    功能： 退出一个进程
    参数： 默认为0 整数表示进程退出状态 
           字符串 则在进程退出时打印该字符串

三、 孤儿进程和僵尸进程

     孤儿进程：父进程先于子进程退出此时子进程成为孤儿
             进程

       * 孤儿进程会被系统进程收养，此时系统进程就会成
        为该进程新的父进程

     僵尸进程：子进程先于父进程退出，父进程没有处理
             进程的退出状态，此时子进程就会成为僵尸
             进程

       * 僵尸进程虽然结束但是会存留部分PCB在内存，大
        量僵尸进程会占用内存资源

     如何处理僵尸进程

       1. 父进程中使用函数处理子进程退出状态
          
	  pid,status = os.wait()
          功能： 阻塞等待处理子进程退出
	  返回值： pid  退出的子进程的PID
	           status 子进程的退出状态
	
	  pid,status = os.waitpid(pid,option)
          功能： 阻塞等待处理子进程退出
	  参数： pid  -1  表示等待任意子进程退出
	              >0  等待指定PID的子进程退出
		 option  0  表示阻塞等待
                         WNOHANG 表示非阻塞
	  返回值：   pid    退出的子进程的PID
	           status  子进程的退出状态
       
       2. 创建二级子进程
	  【1】 父进程创建子进程等待子进程退出
	  【2】 子进程创建二级子进程后立即退出
	  【3】 将事件交由父进程和二级子进程完成，
	        一级子进程被回收，二级子进程成为孤儿，都保护会变成僵尸。

